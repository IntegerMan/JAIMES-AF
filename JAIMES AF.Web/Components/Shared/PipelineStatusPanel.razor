@using MattEland.Jaimes.ServiceDefinitions.Responses
@using Microsoft.AspNetCore.SignalR.Client
@rendermode InteractiveServer
@implements IAsyncDisposable
@inject IHttpClientFactory HttpClientFactory
@inject ISnackbar Snackbar

<MudPaper Class="@CombinedClass" Elevation="2">
    <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Class="mb-4">
        <MudText Typo="Typo.h6">Document Processing Pipeline</MudText>
        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
            @if (_isConnected)
            {
                <MudChip T="string" Color="Color.Success" Size="Size.Small" Icon="@Icons.Material.Filled.SignalCellular4Bar">Live</MudChip>
            }
            else
            {
                <MudChip T="string" Color="Color.Warning" Size="Size.Small" Icon="@Icons.Material.Filled.SignalCellularOff">Connecting...</MudChip>
            }
            <MudTooltip Text="Refresh">
                <MudIconButton Icon="@Icons.Material.Filled.Refresh" OnClick="RefreshStatus" Size="Size.Small" />
            </MudTooltip>
        </MudStack>
    </MudStack>

    @if (_isLoading)
    {
        <MudProgressLinear Indeterminate="true" Color="Color.Primary" Class="mb-4" />
    }

    @if (_status != null)
    {
        <MudStack Row="true" Spacing="2" Class="flex-wrap" AlignItems="AlignItems.Center" Justify="Justify.Center">
            @* Cracking Stage *@
            <MudPaper Class="pa-3" Elevation="1" Style="min-width: 120px; text-align: center;">
                <MudStack AlignItems="AlignItems.Center" Spacing="1">
                    <MudIcon Icon="@Icons.Material.Filled.ContentCut" Size="Size.Large" Color="@GetStageColor(_status.CrackingQueueSize)" />
                    <MudText Typo="Typo.subtitle2">Cracking</MudText>
                    <MudText Typo="Typo.h5" Color="@GetStageColor(_status.CrackingQueueSize)">
                        @_status.CrackingQueueSize
                    </MudText>
                    <MudText Typo="Typo.caption" Class="text-muted">queued</MudText>
                </MudStack>
            </MudPaper>

            @* Arrow *@
            <MudIcon Icon="@Icons.Material.Filled.ArrowForward" Size="Size.Large" Class="text-muted" />

            @* Chunking Stage *@
            <MudPaper Class="pa-3" Elevation="1" Style="min-width: 120px; text-align: center;">
                <MudStack AlignItems="AlignItems.Center" Spacing="1">
                    <MudIcon Icon="@Icons.Material.Filled.ViewModule" Size="Size.Large" Color="@GetStageColor(_status.ChunkingQueueSize)" />
                    <MudText Typo="Typo.subtitle2">Chunking</MudText>
                    <MudText Typo="Typo.h5" Color="@GetStageColor(_status.ChunkingQueueSize)">
                        @_status.ChunkingQueueSize
                    </MudText>
                    <MudText Typo="Typo.caption" Class="text-muted">queued</MudText>
                </MudStack>
            </MudPaper>

            @* Arrow *@
            <MudIcon Icon="@Icons.Material.Filled.ArrowForward" Size="Size.Large" Class="text-muted" />

            @* Embedding Stage *@
            <MudPaper Class="pa-3" Elevation="1" Style="min-width: 120px; text-align: center;">
                <MudStack AlignItems="AlignItems.Center" Spacing="1">
                    <MudIcon Icon="@Icons.Material.Filled.Memory" Size="Size.Large" Color="@GetStageColor(_status.EmbeddingQueueSize)" />
                    <MudText Typo="Typo.subtitle2">Embedding</MudText>
                    <MudText Typo="Typo.h5" Color="@GetStageColor(_status.EmbeddingQueueSize)">
                        @_status.EmbeddingQueueSize
                    </MudText>
                    <MudText Typo="Typo.caption" Class="text-muted">queued</MudText>
                </MudStack>
            </MudPaper>

            @* Arrow *@
            <MudIcon Icon="@Icons.Material.Filled.ArrowForward" Size="Size.Large" Class="text-muted" />

            @* Ready Stage *@
            <MudPaper Class="pa-3" Elevation="1" Style="min-width: 120px; text-align: center;">
                <MudStack AlignItems="AlignItems.Center" Spacing="1">
                    <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Large" Color="Color.Success" />
                    <MudText Typo="Typo.subtitle2">Ready</MudText>
                    <MudText Typo="Typo.h5" Color="Color.Success">
                        @_status.ReadyCount
                    </MudText>
                    <MudText Typo="Typo.caption" Class="text-muted">documents</MudText>
                </MudStack>
            </MudPaper>
        </MudStack>

        <MudText Typo="Typo.caption" Class="mt-4 text-center text-muted">
            Last updated: @_status.Timestamp.ToLocalTime().ToString("g")
            @if (!string.IsNullOrEmpty(_status.WorkerSource))
            {
                <text> â€¢ Source: @_status.WorkerSource</text>
            }
        </MudText>
    }
    else if (!_isLoading)
    {
        <MudAlert Severity="Severity.Info">Unable to retrieve pipeline status.</MudAlert>
    }
</MudPaper>

@code {
    private PipelineStatusNotification? _status;
    private HubConnection? _hubConnection;
    private bool _isConnected;
    private bool _isLoading = true;

    /// <summary>
    /// Additional CSS class to apply to the component.
    /// </summary>
    [Parameter]
    public string? Class { get; set; }

    private string CombinedClass => string.IsNullOrEmpty(Class) ? "pa-4" : $"pa-4 {Class}";

    protected override async Task OnInitializedAsync()
    {
        await SetupSignalRConnection();
        await RefreshStatus();
    }

    private async Task SetupSignalRConnection()
    {
        try
        {
            HttpClient apiClient = HttpClientFactory.CreateClient("Api");
            string hubUrl = new Uri(apiClient.BaseAddress!, "/hubs/pipeline-status").ToString();

            _hubConnection = new HubConnectionBuilder()
                .WithUrl(hubUrl)
                .WithAutomaticReconnect()
                .Build();

            _hubConnection.On<PipelineStatusNotification>("PipelineStatusUpdated", async (notification) =>
            {
                await InvokeAsync(() =>
                {
                    _status = notification;
                    StateHasChanged();
                });
            });

            _hubConnection.Reconnecting += _ =>
            {
                _isConnected = false;
                InvokeAsync(StateHasChanged);
                return Task.CompletedTask;
            };

            _hubConnection.Reconnected += _ =>
            {
                _isConnected = true;
                InvokeAsync(async () =>
                {
                    await _hubConnection.InvokeAsync("SubscribeToPipelineStatus");
                    StateHasChanged();
                });
                return Task.CompletedTask;
            };

            await _hubConnection.StartAsync();
            await _hubConnection.InvokeAsync("SubscribeToPipelineStatus");
            _isConnected = true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to connect to SignalR hub: {ex.Message}");
            _isConnected = false;
        }
    }

    private async Task RefreshStatus()
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            HttpClient client = HttpClientFactory.CreateClient("Api");
            _status = await client.GetFromJsonAsync<PipelineStatusNotification>("/admin/pipeline-status");
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to fetch pipeline status: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isLoading = false;
            StateHasChanged();
        }
    }

    private static Color GetStageColor(int queueSize)
    {
        return queueSize switch
        {
            0 => Color.Default,
            <= 5 => Color.Info,
            <= 20 => Color.Warning,
            _ => Color.Error
        };
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            try
            {
                await _hubConnection.InvokeAsync("UnsubscribeFromPipelineStatus");
            }
            catch
            {
                // Ignore errors during cleanup
            }

            await _hubConnection.DisposeAsync();
        }
    }
}
