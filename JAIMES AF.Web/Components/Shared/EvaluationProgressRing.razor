@using MattEland.Jaimes.ServiceDefinitions.Responses
@using MattEland.Jaimes.Web.Components.Helpers
@using MudBlazor

@* Pie chart that shows evaluation metric progress with color-coded wedges *@

<svg class="evaluation-pie" width="@Size" height="@Size" viewBox="0 0 100 100" 
     style="display: inline-block; vertical-align: middle; margin-top: 4px; cursor: pointer;">
            @if (TotalSegments == 1)
            {
                @* Single segment - render as a full circle since SVG arcs can't render 360 degrees *@
                var metric = Metrics?.FirstOrDefault();
                var singleWedge = GetWedge(0, 0, 360);
                <circle cx="50" cy="50" r="48" fill="@singleWedge.Color" 
                        class="@(singleWedge.IsCompleted ? "wedge-completed" : "")"
                        @onclick="@(() => HandleSliceClick(metric))"
                        @onclick:stopPropagation="true" />
            }
            else if (TotalSegments > 1)
            {
                @* Render pie wedges *@
                double startAngle = 0;
                double anglePerSegment = 360.0 / TotalSegments;
                
                @for (int i = 0; i < TotalSegments; i++)
                {
                    int index = i;
                    var metric = (Metrics != null && index < Metrics.Count) ? Metrics[index] : null;
                    var wedge = GetWedge(index, startAngle, anglePerSegment);
                    <path d="@wedge.Path" fill="@wedge.Color" 
                          class="@(wedge.IsCompleted ? "wedge-completed" : "")"
                          @onclick="@(() => HandleSliceClick(metric))"
                          @onclick:stopPropagation="true" />
                    startAngle += anglePerSegment;
                }
                
                @* Optional center dot for visual balance *@
                <circle cx="50" cy="50" r="8" fill="var(--mud-palette-background)"/>
            }
            else
            {
                @* Empty state - gray circle *@
                <circle cx="50" cy="50" r="48" fill="var(--mud-palette-grey-lighter)"/>
            }
</svg>

<style>
    .evaluation-pie {
        display: inline-block;
    }
    
    .wedge-completed {
        transition: fill 0.3s ease-in-out;
    }
    
    .wedge-completed:hover {
        filter: brightness(1.1);
        stroke: rgba(255,255,255,0.5);
        stroke-width: 1px;
    }
</style>

@code {
    /// <summary>
    /// The total number of expected metrics/segments.
    /// </summary>
    [Parameter]
    public int TotalSegments { get; set; }

    /// <summary>
    /// The list of completed metrics with their scores.
    /// </summary>
    [Parameter]
    public List<MessageEvaluationMetricResponse>? Metrics { get; set; }

    /// <summary>
    /// Dictionary of error states by metric name.
    /// </summary>
    [Parameter]
    public Dictionary<string, string>? ErrorsByMetric { get; set; }

    /// <summary>
    /// Size of the pie chart in pixels.
    /// </summary>
    [Parameter]
    public int Size { get; set; } = 20;

    /// <summary>
    /// Whether evaluation is currently in progress.
    /// </summary>
    [Parameter]
    public bool IsProcessing { get; set; }

    /// <summary>
    /// Event callback when a slice is clicked.
    /// </summary>
    [Parameter]
    public EventCallback<MessageEvaluationMetricResponse> OnSliceClick { get; set; }

    private int CompletedCount => Metrics?.Count ?? 0;
    private bool HasError => ErrorsByMetric?.Any() ?? false;

    private record WedgeInfo(string Path, string Color, bool IsCompleted);

    private WedgeInfo GetWedge(int index, double startAngle, double angleSize)
    {
        // Determine color based on metric state
        string color;
        bool isCompleted = false;
        
        if (Metrics != null && index < Metrics.Count)
        {
            var metric = Metrics[index];
            
            if (ErrorsByMetric != null && ErrorsByMetric.ContainsKey(metric.MetricName))
            {
                color = GetMudColor(Color.Error);
            }
            else
            {
                color = GetMetricColor(metric.Score);
            }
            isCompleted = true;
        }
        else
        {
            // Pending - light gray
            color = "var(--mud-palette-grey-lighter)";
        }
        
        // Generate SVG arc path
        string path = CreatePieSlicePath(50, 50, 48, startAngle, angleSize);
        
        return new WedgeInfo(path, color, isCompleted);
    }

    private string GetMetricColor(double score)
    {
        var scoreColor = MetricColorHelper.GetScoreColor(score);
        return GetMudColor(scoreColor);
    }

    private static string CreatePieSlicePath(double cx, double cy, double r, double startAngle, double angleSize)
    {
        // Convert angles to radians
        double startRad = (startAngle - 90) * Math.PI / 180; // -90 to start at top
        double endRad = (startAngle + angleSize - 90) * Math.PI / 180;
        
        // Calculate start and end points
        double x1 = cx + r * Math.Cos(startRad);
        double y1 = cy + r * Math.Sin(startRad);
        double x2 = cx + r * Math.Cos(endRad);
        double y2 = cy + r * Math.Sin(endRad);
        
        // Large arc flag
        int largeArc = angleSize > 180 ? 1 : 0;
        
        // Format with invariant culture for SVG
        var inv = System.Globalization.CultureInfo.InvariantCulture;
        
        return $"M {cx.ToString(inv)} {cy.ToString(inv)} L {x1.ToString(inv)} {y1.ToString(inv)} A {r.ToString(inv)} {r.ToString(inv)} 0 {largeArc} 1 {x2.ToString(inv)} {y2.ToString(inv)} Z";
    }

    private static string GetMudColor(Color color) => color switch
    {
        Color.Success => "var(--mud-palette-success)",
        Color.Info => "var(--mud-palette-info)",
        Color.Warning => "var(--mud-palette-warning)",
        Color.Error => "var(--mud-palette-error)",
        Color.Secondary => "var(--mud-palette-secondary)",
        _ => "var(--mud-palette-grey-default)"
    };

    private async Task HandleSliceClick(MessageEvaluationMetricResponse? metric)
    {
        if (metric != null && OnSliceClick.HasDelegate)
        {
            await OnSliceClick.InvokeAsync(metric);
        }
    }
}
