@page "/games/{GameId:guid}"
@using MattEland.Jaimes.Web.Components.Helpers
@using Microsoft.Extensions.AI
@using MudBlazor
@using MattEland.Jaimes.Web.Components.Chat

@rendermode InteractiveServer

<PageTitle>Game Details</PageTitle>

<div class="game-details-page-wrapper">
	<MudContainer MaxWidth="MaxWidth.Large" Class="game-details-wrapper">
        <MudStack Row="true" AlignItems="AlignItems.Center" Class="mb-2">
            <MudBreadcrumbs Items="_breadcrumbs" Separator=">"></MudBreadcrumbs>
        </MudStack>
		@if (_isLoading)
		{
			<MudProgressCircular Indeterminate="true" Class="my-4"/>
		}
		else if (!string.IsNullOrEmpty(_errorMessage))
		{
			<MudAlert Severity="Severity.Error">@_errorMessage</MudAlert>
		}
		else if (_game is null)
		{
			<MudText>(No game loaded)</MudText>
		}
		else
		{
            if (_game != null) UpdateBreadcrumbs($"{_game.ScenarioName} - {_game.PlayerName}");
			<div class="game-header">
				<MudText Typo="Typo.h5" Class="mb-0">Game details</MudText>
				<MudText Typo="Typo.body2" Class="text-muted">
					<strong>@_game!.PlayerName</strong> playing <strong>@_game!.ScenarioName</strong>
				</MudText>
				<MudText Typo="Typo.body2" Class="text-muted">
					Ruleset: <strong>@_game!.RulesetName</strong> (@_game!.RulesetId)
				</MudText>
				<MudText Typo="Typo.body2" Class="text-muted">
					Created: @ToLocalTime(_game!.CreatedAt).ToString("g")
					@if (_game!.LastPlayedAt.HasValue)
					{
						<span> | Last played: @ToLocalTime(_game!.LastPlayedAt.Value).ToString("g")</span>
					}
				</MudText>
				<MudText Typo="Typo.body2" Class="text-muted">Game @_game!.GameId</MudText>
			</div>

			<div id="chat-scroll-container" class="chat-scroll">
				@for (int msgIndex = 0; msgIndex < (_messages?.Count ?? 0); msgIndex++)
				{
					var m = _messages![msgIndex];
                    int capturedIndex = msgIndex; // Capture for lambda closure structure below

					// Skip empty messages
					if (string.IsNullOrWhiteSpace(m.Text))
					{
						continue;
					}

					int? messageId = GetMessageId(msgIndex);
					
					// Pre-calculate data needed for components (avoiding dictionary lookups in render loop logic where possible)
					MessageFeedbackResponse? feedback = messageId.HasValue && _messageFeedback.TryGetValue(messageId.Value, out var fb) ? fb : null;
					List<MessageToolCallResponse>? toolCalls = messageId.HasValue && _messageToolCalls.TryGetValue(messageId.Value, out var tc) ? tc : null;
					List<MessageEvaluationMetricResponse>? metrics = messageId.HasValue && _messageMetrics.TryGetValue(messageId.Value, out var met) ? met : null;
                    MessageSentimentInfo? sentimentInfo = messageId.HasValue && _messageSentiment.TryGetValue(messageId.Value, out var si) ? si : null;

					List<string> paragraphs = ChatHelpers.SplitIntoParagraphs(m.Text).ToList();
					@foreach ((string paragraph, int index) in paragraphs.Select((p, i) => (p, i)))
					{
						bool isFirstParagraph = index == 0;
						bool isLastParagraph = index == paragraphs.Count - 1;
						
						@if (m.Role == ChatRole.User)
						{
						    <UserChatMessage 
						        Text="@paragraph" 
						        IsFirstParagraph="@isFirstParagraph"
						        IsLastParagraph="@isLastParagraph"
						        MessageId="@messageId"
                                Sentiment="@sentimentInfo?.Sentiment"
                                Confidence="@sentimentInfo?.Confidence"
                                SentimentSource="@sentimentInfo?.SentimentSource" />
						}
						else
						{
							@if (!string.IsNullOrWhiteSpace(paragraph))
							{
								    <AssistantChatMessage
								        Text="@paragraph"
								        MessageId="@messageId"
								        IsFirstParagraph="@isFirstParagraph"
								        IsLastParagraph="@isLastParagraph"
								        ToolCalls="@toolCalls"
                                        Metrics="@metrics"
								        Feedback="@feedback"
								        OnToolCallsClick="@OnToolCallClicked"
								        OnFeedbackClick="@OnFeedbackClicked"
								        OnMetricsClick="@OnMetricsClicked"
								        ReadOnly="false" />
							}
						}
					}

                    @if (_failedMessageIndex == msgIndex && !string.IsNullOrEmpty(_errorMessage))
                    {
                        <MudChat ChatPosition="ChatBubblePosition.End">
                            <MudChatBubble Color="Color.Error">
                                <MudIcon Icon="@Icons.Material.Filled.Error" Class="mr-2" Size="Size.Small"/>
                                @_errorMessage
                                <MudButton Size="Size.Small" Color="Color.Inherit" OnClick="@(() => RetryMessageAsync(capturedIndex))" Variant="Variant.Text">
                                    Retry
                                </MudButton>
                            </MudChatBubble>
                        </MudChat>
                    }
				}

				@if (_isSending)
				{
					<MudChat ChatPosition="ChatBubblePosition.Start"
					         Variant="Variant.Filled"
					         Color="Color.Default">
						<MudChatHeader Name="Game Master"/>
						<MudChatBubble>
							<div class="typing-indicator">
								<span></span>
								<span></span>
								<span></span>
							</div>
						</MudChatBubble>
					</MudChat>
				}
			</div>

			<div class="message-bar">
				<MudGrid Class="align-items-center">
					<MudItem xs="10" sm="11">
						<MudTextField @bind-Value="_userMessage.Text" Label="Message" Placeholder="Type a message..."
						              FullWidth="true" Immediate="true" OnKeyDown="OnKeyDown"/>
					</MudItem>
					<MudItem xs="2" sm="1" Class="d-flex justify-end">
						<MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SendMessageAsync">
							Send
						</MudButton>
					</MudItem>
				</MudGrid>
			</div>
		}
	</MudContainer>
</div>

@code {
    private async Task OnToolCallClicked(int messageId)
    {
        await ShowToolCallsDialogAsync(messageId);
    }
    
    private async Task OnFeedbackClicked((int MessageId, bool IsPositive) args)
    {
        await ShowFeedbackDialogAsync(args.MessageId, args.IsPositive);
    }

    private void OnMetricsClicked(int messageId)
    {
        ShowMetricsDialogAsync(messageId);
    }

    private List<BreadcrumbItem> _breadcrumbs = new();

    protected override async Task OnInitializedAsync()
    {
        // Initial breadcrumb state
        UpdateBreadcrumbs("Game Details");
        await base.OnInitializedAsync();
    }
    
    // Helper to update breadcrumbs
    private void UpdateBreadcrumbs(string gameName)
    {
         _breadcrumbs = new List<BreadcrumbItem>
        {
            new BreadcrumbItem("Home", href: "/"),
            new BreadcrumbItem("Games", href: "/games"),
            new BreadcrumbItem(gameName, href: null, disabled: true)
        };
    }
}

